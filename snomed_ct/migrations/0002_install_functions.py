# -*- coding: utf-8 -*-
# Generated by Django 1.9.4 on 2016-04-03 08:49
from __future__ import unicode_literals

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('snomed_ct', '0001_initial'),
    ]

    operations = [
        migrations.RunSQL("""
            CREATE EXTENSION IF NOT EXISTS "pgcrypto";

            --
            -- PostgreSQL implementation of Verhoeff checksum.
            -- Based on the MS-TSQL version found at http://www.stens.ca/kb/VerhoeffCheck
            --
            -- Creates a base function like the TSQL version then 2 functions to be used
            -- to carry out a verifiction (returning true for valid, false for not) and
            -- one to return the calculated checksum digit.
            --
            -- Uses NUMERIC types to allow for extremely large numbers.  PostgreSQL will
            -- automatically promote integer and bigint as needed.
            --
            -- Adapted to PostgreSQL PLPGSQL by Jim Jarvie, 17 FEB 2015.
            --
            -- calculateVerhoeff() returns an integer single digit which is the checksum to be used
            -- verifyVerhoeff() returns a boolean, true for number is valid, false for invalid
            --
            CREATE OR REPLACE FUNCTION checksumVerhoeff(num NUMERIC, calcChecksum BOOLEAN)
              RETURNS INTEGER
            LANGUAGE plpgsql
            AS $$
            DECLARE
              d   CHAR(100) := '0123456789123406789523401789563401289567401239567859876043216598710432765982104387659321049876543210';
              p   CHAR(80) := '01234567891576283094580379614289160435279453126870428657390127938064157046913258';
              inv CHAR(10) := '0432156789';
              c   INTEGER := 0;
              len INTEGER;
              m   INTEGER;
              i   INTEGER := 0;
              n   VARCHAR(255);
            BEGIN
              /* Start Processing */
              n := REVERSE(num :: VARCHAR);
              len := LENGTH(n);

              WHILE (i < len) LOOP
                IF calcChecksum THEN
                  /* Do the CalcChecksum */
                  m := substring(p, (((i + 1) % 8) * 10) + substring(n, i + 1, 1) :: INTEGER + 1, 1) :: INTEGER;
                ELSE
                  /* Do the Checksum */
                  m := substring(p, ((i % 8) * 10) + substring(n, i + 1, 1) :: INTEGER + 1, 1) :: INTEGER;
                END IF;
                c := substring(d, (c * 10 + m + 1), 1) :: INTEGER;
                i:=i + 1;
              END LOOP;

              IF (calcChecksum)
              THEN
                /* Do the CalcChecksum */
                c := substring(inv, c + 1, 1) :: INTEGER;
              END IF;
              RETURN c;
            END
            $$;
            CREATE OR REPLACE FUNCTION verifyVerhoeff(num NUMERIC)
              RETURNS BOOLEAN
            LANGUAGE plpgsql
            AS $$
            BEGIN
              RETURN 0 = checksumVerhoeff(num, FALSE);
            END
            $$;
            CREATE OR REPLACE FUNCTION calculateVerhoeff(num NUMERIC)
              RETURNS INTEGER
            LANGUAGE plpgsql
            AS $$
            BEGIN
              RETURN checksumVerhoeff(num, TRUE);
            END
            $$;

            -- SCTID Generation functions --

            CREATE OR REPLACE FUNCTION new_SCTID(partition_identifier NUMERIC, namespace NUMERIC)
              RETURNS BIGINT
            LANGUAGE plpgsql
            AS $func$
            DECLARE
              sctid  BIGINT;
              tmp_id BIGINT;
            BEGIN
              -- namespace := 9999999;

              IF partition_identifier = 10 THEN
                tmp_id := nextval('extension_concept_' || namespace);
              ELSEIF partition_identifier = 11 THEN
                tmp_id := nextval('extension_description_' || namespace);
              ELSE
                tmp_id := nextval('extension_relationship_' || namespace);
              END IF;

              sctid := (tmp_id * 1000000000) + (namespace * 100) + partition_identifier;

              RETURN (sctid * 10) + calculateVerhoeff(sctid);
            END
            $func$;


            CREATE OR REPLACE FUNCTION new_concept_SCTID(namespace NUMERIC)
              RETURNS BIGINT LANGUAGE plpgsql
            AS $func$
            BEGIN
              RETURN new_SCTID(10, namespace);
            END
            $func$;

            CREATE OR REPLACE FUNCTION new_description_SCTID(namespace NUMERIC)
              RETURNS BIGINT LANGUAGE plpgsql
            AS $func$
            BEGIN
              RETURN new_SCTID(11, namespace);
            END
            $func$;

            CREATE OR REPLACE FUNCTION new_relationship_SCTID(namespace NUMERIC)
              RETURNS BIGINT LANGUAGE plpgsql
            AS $func$
            BEGIN
              RETURN new_SCTID(12, namespace);
            END
            $func$;

            -- Extension functions --

            CREATE OR REPLACE FUNCTION create_simple_lang_refset_entries(fully_specified_name_id BIGINT, prefered_term_id BIGINT, module NUMERIC)
              RETURNS VOID LANGUAGE plpgsql
            AS $func$
            BEGIN
              -- US Egnlish
              INSERT INTO sct2_lang_refset (id, effective_time, active, module_id, refset_id, referenced_component_id, acceptability_id)
              VALUES (gen_random_uuid(), CURRENT_DATE, TRUE, module, 900000000000509007, fully_specified_name_id, 900000000000548007);

              INSERT INTO sct2_lang_refset (id, effective_time, active, module_id, refset_id, referenced_component_id, acceptability_id)
              VALUES (gen_random_uuid(), CURRENT_DATE, TRUE, module, 900000000000509007, prefered_term_id, 900000000000548007);

              -- UK Egnlish
              INSERT INTO sct2_lang_refset (id, effective_time, active, module_id, refset_id, referenced_component_id, acceptability_id)
              VALUES (gen_random_uuid(), CURRENT_DATE, TRUE, module, 900000000000508004, fully_specified_name_id, 900000000000548007);

              INSERT INTO sct2_lang_refset (id, effective_time, active, module_id, refset_id, referenced_component_id, acceptability_id)
              VALUES (gen_random_uuid(), CURRENT_DATE, TRUE, module, 900000000000508004, prefered_term_id, 900000000000548007);
            END
            $func$;


            CREATE OR REPLACE FUNCTION create_snomed_ct_module(module_name TEXT, namespace NUMERIC)
              RETURNS BIGINT LANGUAGE plpgsql
            AS $func$
            DECLARE
              new_module_id BIGINT;
              new_fsn_id    BIGINT;
              new_p_term_id BIGINT;
            BEGIN
              new_module_id := new_concept_SCTID(namespace);

              /* Create module component */
              -- 900000000000074008|Primitive|
              INSERT INTO sct2_concept (id, effective_time, active, module_id, definition_status_id)
              VALUES (new_module_id, CURRENT_DATE, TRUE, new_module_id, 900000000000074008);

              -- 900000000000443000|Module|
              -- 116680003|Is a|
              -- 900000000000011006|Inferred relationship|
              -- 900000000000451002|Some|
              INSERT INTO sct2_relationship (id, effective_time, active, module_id, source_id, destination_id, relationship_group, type_id, characteristic_type_id, modifier_id)
              VALUES (new_relationship_SCTID(namespace), CURRENT_DATE, TRUE, new_module_id, new_module_id, 900000000000443000, 0,
                      116680003, 900000000000011006, 900000000000451002);

              -- 900000000000003001|Fully specified name|
              -- 900000000000017005|Case sensitive|
              new_fsn_id := new_description_SCTID(namespace);
              INSERT INTO sct2_description (id, effective_time, active, module_id, concept_id, language_code, type_id, term, case_significance_id)
              VALUES (new_fsn_id, CURRENT_DATE, TRUE, new_module_id, new_module_id, 'en', 900000000000003001,
                      module_name || ' (core metadata concept)', 900000000000017005);

              -- 900000000000013009|Synonym|
              -- 900000000000017005|Case sensitive|
              new_p_term_id := new_description_SCTID(namespace);
              INSERT INTO sct2_description (id, effective_time, active, module_id, concept_id, language_code, type_id, term, case_significance_id)
              VALUES (new_p_term_id, CURRENT_DATE, TRUE, new_module_id, new_module_id, 'en', 900000000000013009,
                      module_name, 900000000000017005);

              PERFORM create_simple_lang_refset_entries(new_fsn_id, new_p_term_id, new_module_id);

              RETURN new_module_id;
            END
            $func$;


            CREATE OR REPLACE FUNCTION create_snomed_ct_reference_set(reference_set_name TEXT, namespace NUMERIC, module NUMERIC)
              RETURNS BIGINT LANGUAGE plpgsql
            AS $func$
            DECLARE
              new_refset_id BIGINT;
              new_fsn_id    BIGINT;
              new_p_term_id BIGINT;
            BEGIN
              /* Create Reference set component */
              new_refset_id := new_concept_SCTID(namespace);
              INSERT INTO sct2_concept (id, effective_time, active, module_id, definition_status_id)
              VALUES (new_refset_id, CURRENT_DATE, TRUE, module, 900000000000074008);

              INSERT INTO sct2_relationship (id, effective_time, active, module_id, source_id, destination_id, relationship_group, type_id, characteristic_type_id, modifier_id)
              VALUES (new_relationship_SCTID(namespace), CURRENT_DATE, TRUE, module, new_refset_id, 900000000000506000, 0,
                      116680003, 900000000000011006, 900000000000451002);

              new_fsn_id := new_description_SCTID(namespace);
              INSERT INTO sct2_description (id, effective_time, active, module_id, concept_id, language_code, type_id, term, case_significance_id)
              VALUES (new_fsn_id, CURRENT_DATE, TRUE, module, new_refset_id, 'en', 900000000000003001,
                      reference_set_name || ' (core metadata concept)', 900000000000017005);

              new_p_term_id := new_description_SCTID(namespace);
              INSERT INTO sct2_description (id, effective_time, active, module_id, concept_id, language_code, type_id, term, case_significance_id)
              VALUES (new_p_term_id, CURRENT_DATE, TRUE, module, new_refset_id, 'en', 900000000000013009,
                      reference_set_name, 900000000000017005);

              PERFORM create_simple_lang_refset_entries(new_fsn_id, new_p_term_id, module);

              RETURN new_refset_id;
            END
            $func$;
        """, """
            DROP EXTENSION IF EXISTS "pgcrypto";
            DROP FUNCTION IF EXISTS checksumVerhoeff(num NUMERIC, calcChecksum BOOLEAN) CASCADE;
            DROP FUNCTION IF EXISTS verifyVerhoeff(num NUMERIC) CASCADE;
            DROP FUNCTION IF EXISTS calculateVerhoeff(num NUMERIC) CASCADE;
            DROP FUNCTION IF EXISTS new_SCTID(partition_identifier NUMERIC, namespace NUMERIC) CASCADE;
            DROP FUNCTION IF EXISTS new_concept_SCTID(namespace NUMERIC) CASCADE;
            DROP FUNCTION IF EXISTS new_description_SCTID(namespace NUMERIC) CASCADE;
            DROP FUNCTION IF EXISTS new_relationship_SCTID(namespace NUMERIC) CASCADE;
            DROP FUNCTION IF EXISTS create_simple_lang_refset_entries(fully_specified_name_id BIGINT, prefered_term_id BIGINT, module NUMERIC) CASCADE;
            DROP FUNCTION IF EXISTS create_snomed_ct_module(module_name TEXT, namespace NUMERIC) CASCADE;
            DROP FUNCTION IF EXISTS create_snomed_ct_reference_set(reference_set_name TEXT, namespace NUMERIC, module NUMERIC) CASCADE;
        """)
    ]
